[{"categories":null,"content":"SpirngSecurity 用户认证 用户授权 与Shiro对比 SSM+Shiro Spirng Boot/SpirngCloud +Spirng Security SpringSecurity本质上是一个过滤器链：有很多过滤器 FilterSecurityInterceptor：是一个方法级的权限过滤器，基本位于过滤链的最底部 ExceptionTranslationFilter:是一个异常过滤器，用来处理在认证授权过程汇总抛出的异常 UsernamePasswordAuthenticationFilter：对/login的POST请求做拦截，校验表单中用户名，密码。 过滤器是如何进行加载的？ 使用SpringSecurity配置过滤器 DelegatingFilterProxy UserDetailsService接口 查询数据库用户名和密码的过程 创建类继承UsernamePasswordAuthenticationFilter，重写三个方法 创建类实现UserDetailService，编写查询数据过程，返回User对象，这个User对象是安全框架提供对象 PasswordEncoder接口 数据加密接口，用于返回User对象里面密码加密 web权限方案 (1)认证 (2)授权 1、设置登录的用户名和密码 第一种方式：通过配置文件 spring.security.user.name=lorry spring.security.user.password=123456 第二种方式：通过配置类 @Configuration public class SecurityConfig extends WebSecurityConfigurerAdapter { @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { BCryptPasswordEncoder passwordEncoder = new BCryptPasswordEncoder(); String encode = passwordEncoder.encode(\"123\"); auth.inMemoryAuthentication().withUser(\"lorry2\").password(encode).roles(\"admin\"); } @Bean PasswordEncoder passwordEncoder(){ return new BCryptPasswordEncoder(); } } 第三种方式：自定义编写实现类 第一步 创建配置类，设置使用哪个UserDetailsService实现 @Configuration public class SecurityConfig1 extends WebSecurityConfigurerAdapter { @Autowired private UserDetailsService userDetailsService; @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { auth.userDetailsService(userDetailsService).passwordEncoder(passwordEncoder()); } @Bean PasswordEncoder passwordEncoder(){ return new BCryptPasswordEncoder(); } } 第二步 编写实现类，返回User对象，User对象有用户名密码和操作权限 @Service(\"userDetailsService\") public class MyUserDetailsService implements UserDetailsService { @Override public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException { List\u003cGrantedAuthority\u003e role = AuthorityUtils.commaSeparatedStringToAuthorityList(\"role\"); return new User(\"lorry3\",new BCryptPasswordEncoder().encode(\"123\"),role); } } 查询数据库完成用户认证 整合mybatisplus完成数据库操作 引入相关依赖 \u003cdependency\u003e \u003cgroupId\u003emysql\u003c/groupId\u003e \u003cartifactId\u003emysql-connector-java\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.baomidou\u003c/groupId\u003e \u003cartifactId\u003emybatis-plus-boot-starter\u003c/artifactId\u003e \u003cversion\u003e3.4.3.1\u003c/version\u003e \u003c/dependency\u003e 创建数据库和表 创建实体类 配置数据源 mybatisplus配置 @Mapper public interface AdminMapper extends BaseMapper\u003cAdmin\u003e { } 在MyAdminDetailsService调用mapper里面的方法查询数据库进行用户认证 @Service(\"userDetailsService\") public class MyUserDetailsService implements UserDetailsService { @Autowired private AdminMapper adminMapper; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException { //调用adminMapper方法查询数据库 QueryWrapper\u003cAdmin\u003e wrapper = new QueryWrapper(); wrapper.eq(\"username\",username); Admin admin = adminMapper.selectOne(wrapper); //判断 if (admin==null){ throw new UsernameNotFoundException(\"用户名不存在\"); } List\u003cGrantedAuthority\u003e role = AuthorityUtils.commaSeparatedStringToAuthorityList(\"role\"); return new User(admin.getUsername(),new BCryptPasswordEncoder().encode(admin.getPassword()),role); } } 自定义设置登录页面 编写配置类重写configure(HttpSecurity http)方法 @Override protected void configure(HttpSecurity http) throws Exception { http.formLogin() //自定义登录页面 .loginPage(\"/login.html\") .loginProcessingUrl(\"/user/login\") //登录访问路径 .defaultSuccessUrl(\"/test/index\").permitAll() //登录成功之后，跳转路径 .and().authorizeRequests() .antMatchers(\"/\",\"/test/hello\",\"/user/login\").permitAll() //设置哪些路径可以直接访问，不需要认证 .anyRequest().authenticated() .and().csrf().disable(); //关闭csrf防护 } 静态页面name必须要设置成username,password \u003cform action=\"/user/login\" method=\"post\"\u003e 用户名：\u003cinput type=\"text\" name=\"username\"/\u003e \u003cbr/\u003e 密码：\u003cinput type=\"text\" name=\"password\"/\u003e \u003cbr/\u003e \u003cinput type=\"submit\" value=\"login\"/\u003e\u003c/form\u003e 基于角色或者权限进行访问控制 ","date":"2021-10-16","objectID":"/spirngsecurity/:0:0","tags":null,"title":"SpirngSecurity","uri":"/spirngsecurity/"},{"categories":null,"content":"hasAuthority方法 ​ 如果当前的主体具有指定的权限，则返回true，否则返回false 在配置类设置当前访问地址有哪些权限 .antMatchers(\"/test/index\").hasAnyAuthority(\"admins\") //当前登录用户，只有具有admins权限才能访问这个路径 在UserDetailsService，给返回User对象设置权限 List\u003cGrantedAuthority\u003e role = AuthorityUtils.commaSeparatedStringToAuthorityList(\"admins\"); ","date":"2021-10-16","objectID":"/spirngsecurity/:1:0","tags":null,"title":"SpirngSecurity","uri":"/spirngsecurity/"},{"categories":null,"content":"hasAnyAuthority方法 ​ 针对多个权限 //hasAnyAuthority方法 .antMatchers(\"/test/index\").hasAnyAuthority(\"admins\",\"manager\") ​ 第二步勿漏 ","date":"2021-10-16","objectID":"/spirngsecurity/:2:0","tags":null,"title":"SpirngSecurity","uri":"/spirngsecurity/"},{"categories":null,"content":"hasRole方法 底层与前面两个方法不一样 private static String hasRole(String role) { Assert.notNull(role, \"role cannot be null\"); Assert.isTrue(!role.startsWith(\"ROLE_\"), () -\u003e { return \"role should not start with 'ROLE_' since it is automatically inserted. Got '\" + role + \"'\"; }); return \"hasRole('ROLE_\" + role + \"')\"; } 返回的是’ROLE_'+传入的role //hasRole方法 返回ROLE_+hasRole的传入值.antMatchers(\"/test/index\").hasRole(\"sale\") List\u003cGrantedAuthority\u003e role = AuthorityUtils.commaSeparatedStringToAuthorityList(\"admins,ROLE_sale\"); ","date":"2021-10-16","objectID":"/spirngsecurity/:3:0","tags":null,"title":"SpirngSecurity","uri":"/spirngsecurity/"},{"categories":null,"content":"hasAnyRole 表示用户具有任一条件就可以访问，和hasAnyAuthority方法类似 自定义403界面（没有权限访问） 写静态页面 在configure(HttpSecurity http)里面配置 //配置没有权限访问跳转自定义页面http.exceptionHandling().accessDeniedPage(\"/unauth.html\"); 认证授权注解使用 ","date":"2021-10-16","objectID":"/spirngsecurity/:4:0","tags":null,"title":"SpirngSecurity","uri":"/spirngsecurity/"},{"categories":null,"content":"@Secured 判断是否具有角色，另外需注意的是这里匹配的字符串要添加前缀“ROLE_” 使用注解前要开启注解功能！ @EnableGlobalMethodSecurity(securedEnabled=true) 启动类(配置类)开启注解 @EnableGlobalMethodSecurity(securedEnabled=true) 在controller的方法上面使用注解，设置角色 @GetMapping(\"/update\")@Secured({\"ROLE_sale\",\"ROLE_manager\"})public String update(){ return \"hello update\";} userDetailsService设置用户角色 ","date":"2021-10-16","objectID":"/spirngsecurity/:5:0","tags":null,"title":"SpirngSecurity","uri":"/spirngsecurity/"},{"categories":null,"content":"@PreAuthorize @PreAuthorize ：注解适合进入方法前的权限验证，@PreAuthorize可以将登陆用户的roles/permissions参数传到方法中。 启动类(配置类)开启注解 @EnableGlobalMethodSecurity(securedEnabled=true,prePostEnabled = true) 在controller的方法上面使用注解，设置角色 @GetMapping(\"/update\")//@Secured({\"ROLE_sale\",\"ROLE_manager\"})@PreAuthorize(\"hasAnyAuthority('admins')\")public String update(){ return \"hello update\";} userDetailsService设置用户角色 ","date":"2021-10-16","objectID":"/spirngsecurity/:6:0","tags":null,"title":"SpirngSecurity","uri":"/spirngsecurity/"},{"categories":null,"content":"@PostAuthorize @PostAuthorize：注解适合进入方法后的权限验证 @GetMapping(\"/update\")//@Secured({\"ROLE_sale\",\"ROLE_manager\"})// @PreAuthorize(\"hasAnyAuthority('admins')\")@PostAuthorize(\"hasAnyAuthority('admin')\")public String update(){ System.out.println(\"update....\"); return \"hello update\";} ","date":"2021-10-16","objectID":"/spirngsecurity/:7:0","tags":null,"title":"SpirngSecurity","uri":"/spirngsecurity/"},{"categories":null,"content":"@PostFilter @PostFilter 方法返回数据进行过滤 @GetMapping(\"getAll\")@PreAuthorize(\"hasAnyAuthority('admins')\")@PostFilter(\"filterObject.username == 'admin2'\")public List\u003cAdmin\u003e getAllAdmin(){ ArrayList\u003cAdmin\u003e list = new ArrayList\u003c\u003e(); list.add(new Admin(1,\"admin1\",\"666\")); list.add(new Admin(2,\"admin2\",\"888\")); System.out.println(list); return list;} response返回[{“id”:2,“username”:“admin2”,“password”:“888”}] ","date":"2021-10-16","objectID":"/spirngsecurity/:8:0","tags":null,"title":"SpirngSecurity","uri":"/spirngsecurity/"},{"categories":null,"content":"@PreFilter @PreFilter 进入控制器之前对数据进行过滤 首先在service层定义 方法，声明只有admins权限和username为admins的会过滤下来 @PreFilter(\"hasAnyAuthority('admins') and filterObject.username=='admins'\")public List\u003cAdmin\u003e save(List\u003cAdmin\u003e admins){ return admins;} 在controller层下写案例，调用service下的save方法 @GetMapping(\"pre\")@PreAuthorize(\"hasAnyAuthority('admins')\")public List\u003cAdmin\u003e save(){ ArrayList\u003cAdmin\u003e admins = new ArrayList\u003c\u003e(); admins.add(new Admin(1,\"zhangsan\",\"111\")); admins.add(new Admin(2,\"lisi\",\"222\")); admins.add(new Admin(3,\"admins\",\"333\")); return myUserDetailsService.save(admins);} 浏览器返回 [{\"id\":3,\"username\":\"admins\",\"password\":\"333\"}] 用户注销 ","date":"2021-10-16","objectID":"/spirngsecurity/:9:0","tags":null,"title":"SpirngSecurity","uri":"/spirngsecurity/"},{"categories":null,"content":"在登录界面添加一个退出 .defaultSuccessUrl(\"/success.html\").permitAll() //登录成功之后，跳转路径 //success.html 界面登录成功！\u003ca href=\"/logout\"\u003e退出\u003c/a\u003e ","date":"2021-10-16","objectID":"/spirngsecurity/:10:0","tags":null,"title":"SpirngSecurity","uri":"/spirngsecurity/"},{"categories":null,"content":"在配置类中添加一个退出映射 //退出http.logout().logoutUrl(\"/logout\").logoutSuccessUrl(\"/login.html\").permitAll(); 自动登录 ","date":"2021-10-16","objectID":"/spirngsecurity/:11:0","tags":null,"title":"SpirngSecurity","uri":"/spirngsecurity/"},{"categories":null,"content":"cookie技术 ","date":"2021-10-16","objectID":"/spirngsecurity/:12:0","tags":null,"title":"SpirngSecurity","uri":"/spirngsecurity/"},{"categories":null,"content":"安全框架机制 ","date":"2021-10-16","objectID":"/spirngsecurity/:13:0","tags":null,"title":"SpirngSecurity","uri":"/spirngsecurity/"},{"categories":null,"content":"实现原理 SCP17讲原理 ","date":"2021-10-16","objectID":"/spirngsecurity/:13:1","tags":null,"title":"SpirngSecurity","uri":"/spirngsecurity/"},{"categories":null,"content":"具体实现 创建数据库 配置类，注入数据源，配置操作数据库对象 //注入数据源@Autowiredprivate DataSource dataSource;@Beanpublic PersistentTokenRepository persistentTokenRepository(){ JdbcTokenRepositoryImpl jdbcTokenRepository = new JdbcTokenRepositoryImpl(); jdbcTokenRepository.setDataSource(dataSource); //自动创建表 // jdbcTokenRepository.setCreateTableOnStartup(true); return jdbcTokenRepository;} 配置类配置自动登录 //设置记住我.and().rememberMe().tokenRepository(persistentTokenRepository()).tokenValiditySeconds(60) //设置有效时长，单位秒.userDetailsService(userDetailsService) 在登录页面绑定复选框 记住我：\u003cinput type=\"checkbox\" name=\"remember-me\" title=\"记住密码\"/\u003e CSRF 跨站请求伪造 SpringSecurity微服务权限方案 1.什么是微服务 2.微服务认证和授权实现过程 3.完成基于SpringSecurity认证授权案例 ","date":"2021-10-16","objectID":"/spirngsecurity/:13:2","tags":null,"title":"SpirngSecurity","uri":"/spirngsecurity/"},{"categories":null,"content":"springboot自动装配原理入门 ","date":"2021-09-05","objectID":"/springboot_autoconfig/:0:0","tags":null,"title":"Springboot_autoconfig","uri":"/springboot_autoconfig/"},{"categories":null,"content":"引导加载自动配置类 启动类注解@SpringBootApplication是三个注解的合成注解 ","date":"2021-09-05","objectID":"/springboot_autoconfig/:1:0","tags":null,"title":"Springboot_autoconfig","uri":"/springboot_autoconfig/"},{"categories":null,"content":"@SpringBootConfiguration @Configuration。代表当前是一个配置类 Indicates that a class provides Spring Boot application @Configuration. Can be used as an alternative to the Spring’s standard @Configuration annotation so that configuration can be found automatically (for example in tests). 使用它的目的：实现自动装配 Application should only ever include one @SpringBootConfiguration and most idiomatic Spring Boot applications will inherit it from @SpringBootApplication. 一个应用只有一个，并且大多数应用程序从@SpringBootApplication继承它 ","date":"2021-09-05","objectID":"/springboot_autoconfig/:2:0","tags":null,"title":"Springboot_autoconfig","uri":"/springboot_autoconfig/"},{"categories":null,"content":"@ComponentScan 指定扫描那些，spring注解 重点： ","date":"2021-09-05","objectID":"/springboot_autoconfig/:3:0","tags":null,"title":"Springboot_autoconfig","uri":"/springboot_autoconfig/"},{"categories":null,"content":"@EnableAutoConfiguration @EnableAutoConfiguration由@AutoConfigurationPackage和@Import注解合成 @AutoConfigurationPackage 点进去 @Import(AutoConfigurationPackages.Registrar.class) //给容器导入一些组件 public @interface AutoConfigurationPackage {} //利用registrar给容器中导入一系列组件 //将指定的一个包下的所有组件导入进来 再点击Registrar to store the base package from the importing configuration. 存储导入配置中的基本包 register(registry, new PackageImports(metadata).getPackageNames().toArray(new String[0])); 在register打一个断点，DEBUG 计算new PackageImports(metadata).getPackageNames() 发现结果就是我们程序的包名com.lorry **原因：**注解标注在我们的主类上，返回主类所在的包，把包名封装在数组里面然后注册进去。registrar的作用就是把注解所在的包下的组件批量注册进来。 总结： @AutoConfigurationPackage 原理：利用Registrar给容器中导入一系列组件 将指定的一个包下的所有组件导入进来，Springboot02ConfigApplication所在包下。 作用：自动配置包，制定了默认的包规则 @Import(AutoConfigurationImportSelector.class) AutoConfigurationImportSelector下有一个方法叫做selectImports，这个函数将所有需要的配置组件转成String数组返回出去 selectImport调用了getAutoConfigurationEnrty方法 getAutoConfigurationEnrty上图的这一行代码 包下刚开始会初始化全部的configurations 原始数量有131个 过滤后只剩下25个 step into 会跳到AutoConfigurationImportSelector.java的getCandidateConfigurations上 点loadFactoryNames()这个方法，这个方法返回loadSpringFactories()会跳转到SpringFactoriesLoader.java上的得到一个重要的方法： Map\u003cString, List\u003cString\u003e\u003e loadSpringFactories(ClassLoader classLoader) 利用工厂加载上述方法， 作用：得到所有的组件 我们在这个方法上打一个断点 这行代码获取资源文件，FACTORIES_RESOURCE_LOCATION代表资源文件的位置 Enumeration\u003cURL\u003e urls = classLoader.getResources(FACTORIES_RESOURCE_LOCATION); 从META-INF/spring.factories位置来加载一个文件， 默认扫描我们当前系统里面所有META-INF/spring.factories位置的文件 例如 ==最核心的包== 点进这个包下的spring.factories里 有一个EnableAutoConfiguration，从它下面到 都是我们的自动配置类 156-26+1正好等于我们上面131个configurations 文件写死了springboot一启动就要给容器加载的所有配置类 # Auto Configure org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\ org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\ org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\ org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\\ org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\\ org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\\ org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\\ org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\\ org.springframework.boot.autoconfigure.context.LifecycleAutoConfiguration,\\ org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\\ org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\\ org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\\ org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\\ org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\\ org.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveDataAutoConfiguration,\\ org.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveRepositoriesAutoConfiguration,\\ org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\\ org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\\ org.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveDataAutoConfiguration,\\ org.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveRepositoriesAutoConfiguration,\\ org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\\ org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\\ org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\\ org.springframework.boot.autoconfigure.data.elasticsearch.ReactiveElasticsearchRepositoriesAutoConfiguration,\\ org.springframework.boot.autoconfigure.data.elasticsearch.ReactiveElasticsearchRestClientAutoConfiguration,\\ org.springframework.boot.autoconfigure.data.jdbc.JdbcRepositoriesAutoConfiguration,\\ org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoCo","date":"2021-09-05","objectID":"/springboot_autoconfig/:4:0","tags":null,"title":"Springboot_autoconfig","uri":"/springboot_autoconfig/"},{"categories":null,"content":"按需开启自动配置项 虽然我们131个场景的所有自动配置启动的时候默认全部加载。xxxxAutoConfiguration 按照条件装配规则（@Conditional），最终会按需配置。 例如：我们点开 以AopAutoConfiguration为例子： 首先说明是一个配置类，@Configuration(proxyBeanMethods = false)代表每个@Bean方法被调用多少次返回的组件都是新创建的 注意==@ConditionalOnClass==意思我们内路径存在Advice.class我们的配置才生效 @ConditionalOnProperty(prefix = \"spring.aop\", name = \"auto\", havingValue = \"true\", matchIfMissing = true) 判断配置文件是否存在spring.aop.auto这个配置 的配置，并且值为true那么下面值就生效，matchIfMissing,如果你没配，默认值为true 下面有两个class方法 @Configuration(proxyBeanMethods = false) @ConditionalOnClass(Advice.class) static class AspectJAutoProxyingConfiguration {} /* @Configuration(proxyBeanMethods = false)是一个配置类 @ConditionalOnClass(Advice.class)有对应的Advice.class才生效 */ @Configuration(proxyBeanMethods = false) @ConditionalOnMissingClass(\"org.aspectj.weaver.Advice\") @ConditionalOnProperty(prefix = \"spring.aop\", name = \"proxy-target-class\", havingValue = \"true\", matchIfMissing = true) static class ClassProxyingConfiguration {} /* @Configuration(proxyBeanMethods = false)是一个配置类 @ConditionalOnMissingClass(\"org.aspectj.weaver.Advice\") 没有这个Advice才生效，并且说明了对应的配置方法 */ 总结： SpringBoot先加载所有的自动配置类 xxxxxAutoConfiguration 每个自动配置类按照条件进行生效，默认都会绑定配置文件指定的值。xxxxProperties里面拿。xxxProperties和配置文件进行了绑定 生效的配置类就会给容器中装配很多组件 只要容器中有这些组件，相当于这些功能就有了 定制化配置 用户直接自己@Bean替换底层的组件 用户去看这个组件是获取的配置文件什么值就去修改。 xxxxxAutoConfiguration —\u003e 组件 —\u003e xxxxProperties里面拿值 —-\u003e application.properties（配置文件） ","date":"2021-09-05","objectID":"/springboot_autoconfig/:5:0","tags":null,"title":"Springboot_autoconfig","uri":"/springboot_autoconfig/"},{"categories":null,"content":"\r代码 第一个mybatis程序 ","date":"2021-08-19","objectID":"/first_post/:0:0","tags":null,"title":"mybatis笔记","uri":"/first_post/"},{"categories":null,"content":"搭建环境 ","date":"2021-08-19","objectID":"/first_post/:1:0","tags":null,"title":"mybatis笔记","uri":"/first_post/"},{"categories":null,"content":"搭建数据库 CREATEDATABASE`mybatis`;USE`mybatis`;CREATETABLE`user`(`id`INT(20)NOTNULLPRIMARYKEY,`name`VARCHAR(30)DEFAULTNULL,`pwd`VARCHAR(30)DEFAULTNULL)ENGINE=INNODBDEFAULTCHARSET=utf8;INSERTINTO`user`(`id`,`name`,`pwd`)VALUES(1,'张三','123456'),(2,'李四','123456'),(3,'王五','123456'),(4,'赵六','123456'),(5,'肖七','123456') ","date":"2021-08-19","objectID":"/first_post/:1:1","tags":null,"title":"mybatis笔记","uri":"/first_post/"},{"categories":null,"content":"新建项目 新建一个普通的maven’项目（狂神教程是先建一个大的maven项目然后在里面建小项目） 有一个问题：建立了maven06之后删除再建立显示maven06存在，在父目录里面删除后还有 删除src目录 导入maven依赖 \u003c!--daoruyilai--\u003e \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003emysql\u003c/groupId\u003e \u003cartifactId\u003emysql-connector-java\u003c/artifactId\u003e \u003cversion\u003e8.0.25\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis\u003c/groupId\u003e \u003cartifactId\u003emybatis\u003c/artifactId\u003e \u003cversion\u003e3.5.7\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ejunit\u003c/groupId\u003e \u003cartifactId\u003ejunit\u003c/artifactId\u003e \u003cversion\u003e4.12\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c/dependencies\u003e ","date":"2021-08-19","objectID":"/first_post/:1:2","tags":null,"title":"mybatis笔记","uri":"/first_post/"},{"categories":null,"content":"使用mybatis的基础配置 编写mybatis的核心配置文件 在resource文件夹下建立mybatis-config.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"\u003e \u003cconfiguration\u003e \u003cenvironments default=\"development\"\u003e \u003cenvironment id=\"development\"\u003e \u003ctransactionManager type=\"JDBC\"/\u003e \u003cdataSource type=\"POOLED\"\u003e \u003cproperty name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\"/\u003e \u003cproperty name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis?useSSL=true\u0026amp;useUnicode=true\u0026amp;characterEncoding=UTF-8\u0026amp;serverTimezone=Asia/Shanghai\"/\u003e \u003cproperty name=\"username\" value=\"root\"/\u003e \u003cproperty name=\"password\" value=\"123456\"/\u003e \u003c/dataSource\u003e \u003c/environment\u003e \u003c/environments\u003e \u003c!--每一个mapper.xml都需要在Mybatis核心配置文件中注册！--\u003e \u003cmappers\u003e \u003cmapper resource=\"UserMapper.xml\"\u003e\u003c/mapper\u003e \u003c/mappers\u003e \u003c/configuration\u003e 因为使用的是MySQL8.0，注意时区问题 编写mybatis工具类 public class MybatisUtils { private static SqlSessionFactory sqlSessionFactory; //这里不加static会报空指针异常 static{ try { // 使用mybatis获得sqlSessionFactory对象 String resource = \"mybatis-config.xml\"; InputStream inputStream = Resources.getResourceAsStream(resource); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); } catch (IOException e) { e.printStackTrace(); } } /* * 既然有了 SqlSessionFactory，顾名思义，我们可以从中获得 SqlSession 的实例。 * SqlSession 提供了在数据库执行 SQL 命令所需的所有方法。 * 你可以通过 SqlSession 实例来直接执行已映射的 SQL 语句。例如： * */ public static SqlSession getSqlSession(){ // SqlSession sqlSession = sqlSessionFactory.openSession(); // return sqlSession; return sqlSessionFactory.openSession(); } } 参考官方文档，编写工具类的原因是能够更简便的开发 ","date":"2021-08-19","objectID":"/first_post/:1:3","tags":null,"title":"mybatis笔记","uri":"/first_post/"},{"categories":null,"content":"实现CRUD 在lorry下新建maaper文件下存放接口，接口命名为UserMapper public interface UserMapper { //查询全部用户 List\u003cUser\u003e getUserList(); //根据ID查询用户 User getUserById(int id); //map User getUserById2(Map\u003cString,Object\u003emap); //insert一个用户 int addUser(User user); //万能的map int addUser2(Map\u003cString,Object\u003emap); //修改用户 int updateUser(User user); //删除用户 int deleteUser(int id); List\u003cUser\u003e getUserLike(String value); } 在lorry下新建pojo文件夹放实体类并生成有参无参构造get set方法和toString public class User { private int user_id; private String user_name; private String user_pwd; } 在resource下新建UserMapper.xml文件 UserMapper.xml需要在mybatis-config.xml下注册 \u003c!--每一个mapper.xml都需要在Mybatis核心配置文件中注册！--\u003e \u003cmappers\u003e \u003cmapper resource=\"UserMapper.xml\"\u003e\u003c/mapper\u003e \u003c/mappers\u003e 配置可以写resource也可以写class，写class直接对应着类，用注释的时候常用 每一个namespace对应一个Mapper接口 \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"\u003e \u003c!--namesapce绑定一个个对应的Dao/mapper接口--\u003e \u003cmapper namespace=\"com.lorry.mapper.UserMapper\"\u003e \u003cselect id=\"getUserList\" resultType=\"com.lorry.pojo.User\"\u003e select * from mybatis.user \u003c/select\u003e \u003cselect id=\"getUserById\" parameterType=\"int\" resultType=\"com.lorry.pojo.User\"\u003e select * from mybatis.user where user_id = #{id} \u003c/select\u003e \u003cinsert id=\"addUser\" parameterType=\"com.lorry.pojo.User\"\u003e insert into mybatis.user(user_id, user_name, user_pwd) value (#{user_id}, #{user_name}, #{user_pwd}); \u003c/insert\u003e \u003cupdate id=\"updateUser\" parameterType=\"com.lorry.pojo.User\"\u003e update mybatis.user set user_name=#{user_name}, user_pwd=#{user_pwd} where user_id=#{user_id}; \u003c/update\u003e \u003cdelete id=\"deleteUser\" parameterType=\"int\"\u003e delete from mybatis.user where user_id=#{user_id}; \u003c/delete\u003e \u003c!--使用map，传递map中的key, 实体类或数据库里面的表字段或者参数过多，考虑使用map--\u003e \u003cinsert id=\"addUser2\" parameterType=\"map\"\u003e insert into mybatis.user(user_id, user_name, user_pwd) value (#{id}, #{name}, #{pwd}); \u003c/insert\u003e \u003cselect id=\"getUserById2\" parameterType=\"map\" resultType=\"com.lorry.pojo.User\"\u003e select * from mybatis.user where user_id = #{id} and user_name = #{name} \u003c/select\u003e \u003cselect id=\"getUserLike\" resultType=\"com.lorry.pojo.User\"\u003e select * from mybatis.user where user_name like concat('%',#{name},'%'); \u003c/select\u003e \u003c/mapper\u003e 增删改需要提交事务，可以在工具类里面修改默认提交 ","date":"2021-08-19","objectID":"/first_post/:2:0","tags":null,"title":"mybatis笔记","uri":"/first_post/"},{"categories":null,"content":"测试 这里主要用到了mybatis的工具类 @Test public void test(){ /* * 从SqlSession执行sql * 先拿到sql * UserMapper是UserDao的实现类 *面向接口编程所以我们们拿到接口“UserDao.class”就可以 * 返回后就可以执行接口的方法了 * */ //第一步获得SqlSession对象 //这里使用了try-with-resources不必写sqlSession.close(); try(SqlSession sqlSession = MybatisUtils.getSqlSession()){ //方式1：执行SQL UserMapper mapper = sqlSession.getMapper(UserMapper.class); List\u003cUser\u003e userList = mapper.getUserList(); //方式2：不推荐使用 // List\u003cUser\u003e userList = sqlSession.selectList(\"com.lorry.dao.UserDao.getUserList\"); for (User user : userList) { //输出的是地址原因是没写toString System.out.println(user); } } } ","date":"2021-08-19","objectID":"/first_post/:2:1","tags":null,"title":"mybatis笔记","uri":"/first_post/"},{"categories":null,"content":"Map传递参数 \u003c!--使用map，传递map中的key, 实体类或数据库里面的表字段或者参数过多，考虑使用map--\u003e \u003cinsert id=\"addUser2\" parameterType=\"map\"\u003e insert into mybatis.user(user_id, user_name, user_pwd) value (#{id}, #{name}, #{pwd}); \u003c/insert\u003e \u003cselect id=\"getUserById2\" parameterType=\"map\" resultType=\"com.lorry.pojo.User\"\u003e select * from mybatis.user where user_id = #{id} and user_name = #{name} \u003c/select\u003e @Test public void getUserById2(){ try(SqlSession sqlSession = MybatisUtils.getSqlSession()){ UserMapper mapper = sqlSession.getMapper(UserMapper.class); Map\u003cString, Object\u003e map = new HashMap\u003cString,Object\u003e(); map.put(\"id\",2); map.put(\"name\",\"梅世杰\"); User user = mapper.getUserById2(map); System.out.println(user); } } **使用map优点：**如果一个表中的字段非常多而需要的字段只有少数时，new一个实体对象显然很麻烦，需要对所有的字段都进行一次赋值。使用map传值可以更方便的实现需要进行的操作。如：修改用户密码时，只需要传入id和密码即可，而无需new一个用户对象。 ","date":"2021-08-19","objectID":"/first_post/:3:0","tags":null,"title":"mybatis笔记","uri":"/first_post/"},{"categories":null,"content":"mybatis的模糊查询 ","date":"2021-08-19","objectID":"/first_post/:4:0","tags":null,"title":"mybatis笔记","uri":"/first_post/"},{"categories":null,"content":"方式一： 手动添加“%” 通配符 xml配置： \u003c!--模糊查询--\u003e\u003cselect id=\"fuzzyQuery\" resultType=\"com.bin.pojo.Book\"\u003e select * from mybatis.book where bookName like #{info};\u003c/select\u003e @Test public void fuzzyQuery(){ SqlSession sqlSession = MybatisUtils.getSqlSession(); BookMapper mapper = sqlSession.getMapper(BookMapper.class); List\u003cBook\u003e books = mapper.fuzzyQuery(\"%萨%\"); for (Book book : books) { System.out.println(book); } sqlSession.close(); } **说明：**需要手动添加”%”通配符，显然这种方式很麻烦，并且如果忘记添加通配符的话就会变成普通的查询语句，匹配全部字符查询。 缺点： 麻烦 易出错 ","date":"2021-08-19","objectID":"/first_post/:4:1","tags":null,"title":"mybatis笔记","uri":"/first_post/"},{"categories":null,"content":"方式二 在xml配置文件中添加”%”通配符，拼接字符串形式 \u003cselect id=\"fuzzyQuery\" resultType=\"com.bin.pojo.Book\"\u003e select * from mybatis.book where bookName like '%${info}%'; \u003c/select\u003e **说明：**在mapper.xml配置文件中添加”%”通配符，但是需要用单引号将其包裹住，但是用单引号裹住之后#{}就无法被识别，要改成${}这种拼接字符串的形式。虽然通过方式二优化了方式一的缺点，但同时也造成了SQL安全性的问题，也就是用户可以进行SQL注入。 缺点： 不安全，可进行SQL注入 ","date":"2021-08-19","objectID":"/first_post/:4:2","tags":null,"title":"mybatis笔记","uri":"/first_post/"},{"categories":null,"content":"方式三 在xml配置文件中添加”%”通配符，借助mysql函数 \u003cselect id=\"fuzzyQuery\" resultType=\"com.bin.pojo.Book\"\u003e select * from mybatis.book where bookName like concat('%',#{info},'%');\u003c/select\u003e **说明：**解决了SQL注入且能在配置文件中写”%”通配符的问题，完美实现了模糊查询 优点： 安全 方便 ","date":"2021-08-19","objectID":"/first_post/:4:3","tags":null,"title":"mybatis笔记","uri":"/first_post/"},{"categories":null,"content":"方式四 与方式三一样使用mysql函数，但使的用是${}形式，不过需要用单引号包裹住 \u003cselect id=\"fuzzyQuery\" resultType=\"com.bin.pojo.Book\"\u003e select * from mybatis.book where bookName like concat('%','${info}','%');\u003c/select\u003e 总结： #{}是预编译处理，mybatis在处理#{}时，会将其替换成”?”，再调用PreparedStatement的set方法来赋值。 ${}是拼接字符串，将接收到的参数的内容不加任何修饰的拼接在SQL语句中，会引发SQL注入问题。 配置解析 ","date":"2021-08-19","objectID":"/first_post/:4:4","tags":null,"title":"mybatis笔记","uri":"/first_post/"},{"categories":null,"content":"核心配置 MyBatis 的配置文件包含了会深深影响 MyBatis 行为的设置和属性信息 configuration（配置） properties（属性） settings（设置） typeAliases（类型别名） typeHandlers（类型处理器） objectFactory（对象工厂） plugins（插件） environments（环境配置） environment（环境变量） transactionManager（事务管理器） dataSource（数据源） databaseIdProvider（数据库厂商标识） mappers（映射器） ","date":"2021-08-19","objectID":"/first_post/:5:0","tags":null,"title":"mybatis笔记","uri":"/first_post/"},{"categories":null,"content":"环境配置 MyBatis可以配置成适应多种环境 尽管可以配置多个环境，但每个 SqlSessionFactory 实例只能选择一种环境。 Mybatis默认的事务管理器是JDBC 连接池：POOLED \u003ctransactionManager type=\"JDBC\"/\u003e \u003cdataSource type=\"POOLED\"\u003e ","date":"2021-08-19","objectID":"/first_post/:5:1","tags":null,"title":"mybatis笔记","uri":"/first_post/"},{"categories":null,"content":"属性(properties) 可以通过properties属性来实现引用配置文件 这些属性可以在外部进行配置，并可以进行动态替换。可以在典型的 Java 属性文件中配置这些属性，也可以在 properties 元素的子元素中设置。【db.properties 】 编写一个db.properties driver=com.mysql.cj.jdbc.Driver url=jdbc:mysql://localhost:3306/mybatis?useSSL=true\u0026useUnicode=true\u0026characterEncoding=UTF-8\u0026serverTimezone=Asia/Shanghai username=root password=123456 \u003c!--引入外部配置文件--\u003e \u003cproperties resource=\"db.properties\"/\u003e 可以直接引入外部文件 可以在其中增一些属性配置 如果两个文件有相同的name字段，优先使用外部配置文件的 ","date":"2021-08-19","objectID":"/first_post/:5:2","tags":null,"title":"mybatis笔记","uri":"/first_post/"},{"categories":null,"content":"类型别名(typeAliases) 类取别名 类型别名是java类型设置一个短的名字 存在的意义仅在于用来减少类完全限定名的冗余 \u003c!--可以给实体类取别名--\u003e \u003ctypeAliases\u003e \u003ctypeAlias type=\"com.bin.pojo.User\" alias=\"User\"/\u003e \u003ctypeAlias type=\"com.bin.pojo.Book\" alias=\"Book\"/\u003e \u003c/typeAliases\u003e 指定包 也可以指定一个包名，mybatis在包名下面搜索需要的javaBean 没有注解时，它的默认别名为这个类的类名，首字母小写； \u003ctypeAliases\u003e \u003cpackage name=\"com.lorry.pojo\"/\u003e \u003c/typeAliases\u003e 若有注解，则别名为其注解值。 @Alias(\"author\") public class Author { ... } 在实体类较少的时候，可以使用给类取别名 在实体类十分多时，可以使用指定包 生命周期和作用域 生命周期和作用域是至关重要的，因为错误的使用会导致非常严重的并发问题 SqlSessionFactoryBuilder： 一旦创建SqlSessionFactory就不需要它了 局部变量 SqlSessionFactory： 可以看成数据库连接池 一旦被创建就应该在应用运行期间一直存在，没有任何理由丢弃或者重新创建另一个实例 SqlSessionFactory的最佳作用域是应用作用域 简单的是使用单例模式或者静态单例模式 SqlSession： 相当于连接到连接池的一个请求 SqlSession的实例不是线程安全的，所以不能被共享 它的最佳作用域是请求或方法作用域 用完之后需关闭，否则会浪费资源 SqlSessionFactory可以创建多个SqlSession，每个sqlSession都可以创建多个Mapper 一个Mapper代表着一个具体的业务 解决属性名和字段名不一致的问题 数据库中的字段 实体类的属性 private int user_id; private String user_name; private String user_password; 解决办法： 起别名 selectuser_id,user_name,user_pwdasuser_passwordfrommybatis.userwhereuser_id=#{id} resultmap 结果集映射 \u003c!--结果集映射--\u003e \u003cresultMap id=\"UserMap\" type=\"user\"\u003e \u003c!--column数据库中的字段，property实体类中的属性--\u003e \u003c!-- \u003cresult column=\"user_id\" property=\"user_id\"/\u003e--\u003e \u003c!-- \u003cresult column=\"user_name\" property=\"user_name\"/\u003e--\u003e \u003cresult column=\"user_pwd\" property=\"user_password\"/\u003e \u003c/resultMap\u003e \u003cselect id=\"getUserById\" parameterType=\"int\" resultMap=\"UserMap\"\u003e select * from mybatis.user where user_id = #{id} \u003c/select\u003e resultMap 元素是 MyBatis 中最重要最强大的元素 ResultMap 的设计思想是 对简单的语句做到零配置 对于复杂一点的语句，只需要描述语句之间的关系就行了 一样的字段可以不做映射 日志 ","date":"2021-08-19","objectID":"/first_post/:5:3","tags":null,"title":"mybatis笔记","uri":"/first_post/"},{"categories":null,"content":"日志工程 日志是查找错误的好助手 SLF4J ==LOG4J==⭐ LOG4J2 JDK_LOGGING COMMONS_LOGGING ==STDOUT_LOGGING==⭐ 标准日志输出 NO_LOGGING 在mybatis中具体使用哪一个日志实现，在mybatis核心配置文件中设置 \u003csettings\u003e \u003c!--标准的日志工厂实现--\u003e \u003csetting name=\"logImpl\" value=\"STDOUT_LOGGING\"/\u003e \u003c!-- \u003csetting name=\"logImpl\" value=\"Log4J\"/\u003e--\u003e \u003c/settings\u003e ","date":"2021-08-19","objectID":"/first_post/:6:0","tags":null,"title":"mybatis笔记","uri":"/first_post/"},{"categories":null,"content":"LOG4J LOG4J是Apache的一个开源项目，通过使用Log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI组件 可以控制每一条日志的输出格式 通过定义每一条日志信息的级别，能够更加细致地控制日志的生成过程 通过一个配置文件来灵活地进行配置，而不需要修改应用的代码 导入LOG4J的包 \u003c!-- https://mvnrepository.com/artifact/log4j/log4j --\u003e \u003cdependency\u003e \u003cgroupId\u003elog4j\u003c/groupId\u003e \u003cartifactId\u003elog4j\u003c/artifactId\u003e \u003cversion\u003e1.2.17\u003c/version\u003e \u003c/dependency\u003e log4j.properties配置 #将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码 log4j.rootLogger=DEBUG,console,file #控制台输出的相关设置 log4j.appender.console = org.apache.log4j.ConsoleAppender log4j.appender.console.Target = System.out log4j.appender.console.Threshold=DEBUG log4j.appender.console.layout = org.apache.log4j.PatternLayout log4j.appender.console.layout.ConversionPattern=[%c]-%m%n #文件输出的相关设置 log4j.appender.file = org.apache.log4j.RollingFileAppender log4j.appender.file.File=./log/lorry.log log4j.appender.file.MaxFileSize=10mb log4j.appender.file.Threshold=DEBUG log4j.appender.file.layout=org.apache.log4j.PatternLayout log4j.appender.file.layout.ConversionPattern=[%p][%d{yy-MM-dd}][%c]%m%n #日志输出级别 log4j.logger.org.mybatis=DEBUG log4j.logger.java.sql=DEBUG log4j.logger.java.sql.Statement=DEBUG log4j.logger.java.sql.ResultSet=DEBUG log4j.logger.java.sql.PreparedStatement=DEBUG 配置log4j为日志实现 \u003csettings\u003e \u003c!--标准的日志工厂实现--\u003e \u003c!-- \u003csetting name=\"logImpl\" value=\"STDOUT_LOGGING\"/\u003e--\u003e \u003csetting name=\"logImpl\" value=\"Log4J\"/\u003e \u003c/settings\u003e ","date":"2021-08-19","objectID":"/first_post/:7:0","tags":null,"title":"mybatis笔记","uri":"/first_post/"},{"categories":null,"content":"简单实用 在使用Log4j的类中，导入包import org.apache.log4j.Logger; 由于多个类会使用，设置为静态 logger.info(\"info:进入了testLog4j\"); logger.debug(\"debug:进入了testLog4j\"); logger.error(\"error:进入了testLog4j\"); 使用mybatis实现分页 ","date":"2021-08-19","objectID":"/first_post/:7:1","tags":null,"title":"mybatis笔记","uri":"/first_post/"},{"categories":null,"content":"使用Limit分页（代码在mybatis_04） 接口 //分页 List\u003cUser\u003e getUserByLimit(Map\u003cString,Integer\u003e map); Mapper.xml \u003c!--//分页--\u003e \u003cselect id=\"getUserByLimit\" parameterType=\"map\" resultType=\"User\"\u003e select * from mybatis.user limit #{startIndex},#{endIndex} \u003c/select\u003e 测试 @Test public void getUserByLimit(){ try(SqlSession sqlSession = MybatisUtils.getSqlSession()){ UserMapper mapper = sqlSession.getMapper(UserMapper.class); Map\u003cString, Integer\u003e map = new HashMap\u003cString,Integer\u003e(); map.put(\"startIndex\",1); map.put(\"endIndex\",4); List\u003cUser\u003e userList = mapper.getUserByLimit(map); for (User user : userList) { logger.info(\"分页查询用户：\" + user); } } } ","date":"2021-08-19","objectID":"/first_post/:8:0","tags":null,"title":"mybatis笔记","uri":"/first_post/"},{"categories":null,"content":"RewBounds分页 接口 // 分页2 List\u003cUser\u003e gteUserByRowBounds(); UserMapper.xml \u003c!--//分页2--\u003e \u003cselect id=\"getUserByRowBounds\" parameterType=\"map\" resultMap=\"UserMap\"\u003e select * from mybatis.user \u003c/select\u003e 测试 @Test public void getUserByRowBounds(){ try(SqlSession sqlSession = MybatisUtils.getSqlSession()){ RowBounds rowBounds = new RowBounds(1, 4); //通过java代码层面实现分页 List\u003cUser\u003e userList = sqlSession.selectList(\"com.lorry.mapper.UserMapper.getUserByRowBounds\",null,rowBounds); for (User user : userList) { System.out.println(user); } } } ","date":"2021-08-19","objectID":"/first_post/:9:0","tags":null,"title":"mybatis笔记","uri":"/first_post/"},{"categories":null,"content":"分页插件 使用注解开发 ","date":"2021-08-19","objectID":"/first_post/:10:0","tags":null,"title":"mybatis笔记","uri":"/first_post/"},{"categories":null,"content":"面向接口编程 之前学到的都是面向对象编程，也学习过接口，但在真正开发中，很多时候我们会选择面向接口编程； 根本原因 ： 解耦、可扩展、提高复用，分层开发中，上层不用管具体的实现，大家都遵守共同的标准，使得开发变得更容易，规范性更好。 在一个面向对象的系统中，系统的各种功能是由许许多多的不同对象协作完成的，在这种情况下，各个对象内部是如何实现的，对系统设计人员来讲是不那么重要的； 而各个对象之间的协作关系则成为系统设计的关键。小到不同类之间的通信，大到各模块之间的交互，在系统设计之初都是要着重考虑的，这也是系统设计的主要工作内容。面向接口编程就是按照这种思想来编程。 关于接口的理解 接口从更深层次的理解，应是定义（规范，约束）与实现（名实分离的原则）的分离。 接口的本身反映了系统设计人员对系统的抽象理解。 接口应有两类： 第一类是对一个个体的抽象，它可对应为一个抽象体(abstract class)； 第二类是对一个个体某一方面的抽象，即形成一个抽象面（interface）； 一个体有可能有多个抽象面。抽象体与抽象面是有区别的。 三个面向区别 面向对象是指，我们考虑问题时，以对象为单位，考虑它的属性及方法 . 面向过程是指，我们考虑问题时，以一个具体的流程（事务过程）为单位，考虑它的实现 . 接口设计与非接口设计是针对复用技术而言的，与面向对象（过程）不是一个问题.更多的体现就是对系统整体的架构 ","date":"2021-08-19","objectID":"/first_post/:10:1","tags":null,"title":"mybatis笔记","uri":"/first_post/"},{"categories":null,"content":"使用注解开发 注解在接口上实现 public interface TeacherMapper { @Select(\"select * from teacher where id = #{tid}\") Teacher getTeacher(@Param(\"tid\") int id); } 在mybatis-config.xml中绑定接口 \u003cmappers\u003e \u003cmapper class=\"com.lorry.mapper.UserMapper\"/\u003e \u003c/mappers\u003e 测试 @Test public void getUsers(){ SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); List\u003cUser\u003e users = mapper.getUsers(); for (User user : users) { logger.info(\"使用注解查询：\" + user); } } 本质：反射机制实现 底层：动态代理 ","date":"2021-08-19","objectID":"/first_post/:11:0","tags":null,"title":"mybatis笔记","uri":"/first_post/"},{"categories":null,"content":"CRUD 在工具类创建的时候可以实现自动提交 publicstaticSqlSession getSqlSession(){ return sqlSessionFactory.openSession(true); } 编写接口 public interface UserMapper02 { @Select(\"select * from user\") List\u003cUser\u003e getUsers(); @Select(\"select * from user where id = #{id}\") List\u003cUser\u003e getUserById(@Param(\"id\") int id); @Insert(\"insert into user(id,name,pwd) values(#{id},#{name},#{pwd})\") int addUser(User user); @Update(\"update user set name=#{name},pwd=#{pwd} where id=#{id}\") int updateUser(User user); @Delete(\"delete from user where id = #{id}\") int deleteUser(@Param(\"id\") int id); } 将接口注册绑定到mybatis-config文件中 \u003cmapper class=\"com.lorry.mapper.UserMapper02\"/\u003e 关于\r@Param()注解 基本类型的参数或String类型需要使用 引用类型不需要 只有一个基本类型可以忽略不写，但建议写上 SQL中引用的是\r@Param()注解中设定的属性名 #{}和${}的区别： #{} 预编译，可避免SQL注入 ${} 拼接字符串，可以被进行SQL注入 Lombok 在IDEA中安装Lombok插件 在项目中导入Lombok的jar包 \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003cversion\u003e1.18.20\u003c/version\u003e \u003cscope\u003eprovided\u003c/scope\u003e \u003c/dependency\u003e 常用的注释 \r@Data 无参构造、get、set、toString、equals、hashcode \r@AllArgsConstructor 有参构造 \r@NoArgsConstructor 无参构造 多对一处理 ","date":"2021-08-19","objectID":"/first_post/:12:0","tags":null,"title":"mybatis笔记","uri":"/first_post/"},{"categories":null,"content":"编写SQL，创建数据库表 CREATETABLE`teacher`(`id`INT(10)NOTNULL,`name`VARCHAR(30)DEFAULTNULL,PRIMARYKEY(`id`))ENGINE=INNODBDEFAULTCHARSET=utf8INSERTINTOteacher(`id`,`name`)VALUES(1,'秦老师');CREATETABLE`student`(`id`INT(10)NOTNULL,`name`VARCHAR(30)DEFAULTNULL,`tid`INT(10)DEFAULTNULL,PRIMARYKEY(`id`),KEY`fktid`(`tid`),CONSTRAINT`fktid`FOREIGNKEY(`tid`)REFERENCES`teacher`(`id`))ENGINE=INNODBDEFAULTCHARSET=utf8INSERTINTO`student`(`id`,`name`,`tid`)VALUES(1,'小明',1);INSERTINTO`student`(`id`,`name`,`tid`)VALUES(2,'小红',1);INSERTINTO`student`(`id`,`name`,`tid`)VALUES(3,'小张',1);INSERTINTO`student`(`id`,`name`,`tid`)VALUES(4,'小李',1);INSERTINTO`student`(`id`,`name`,`tid`)VALUES(5,'小王',1); 导入lombok 创建javaBean(即实体类) 建立Mapper接口 建立Mapper.xml文件 在核心配置文件中绑定mapper接口或配置文件 测试查询 ","date":"2021-08-19","objectID":"/first_post/:13:0","tags":null,"title":"mybatis笔记","uri":"/first_post/"},{"categories":null,"content":"按照查询嵌套处理 \u003cselect id=\"getStudent\" resultMap=\"StudentTeacher\"\u003e select * from Student \u003c/select\u003e \u003cresultMap id=\"StudentTeacher\" type=\"Student\"\u003e \u003cresult property=\"id\" column=\"id\"/\u003e \u003cresult property=\"name\" column=\"name\"/\u003e \u003c!--多对一处理，1。查询出所有的学生信息 2。根据查询出来的学生的tid，寻找对应的老师--\u003e \u003c!--复杂的属性，我们需要单独处理--\u003e \u003c!--对象就用 association--\u003e \u003c!--集合使用 collection--\u003e \u003c!--复杂的属性，我们需要单独处理，我们用association来操作对象，并加了javaType和select 用select来找Teacher--\u003e \u003c!--用这个column tid去查老师--\u003e \u003cassociation property=\"teacher\" column=\"tid\" javaType=\"teacher\" select=\"getTeacher\"/\u003e \u003c/resultMap\u003e \u003cselect id=\"getTeacher\" resultType=\"Teacher\"\u003e select * from teacher where id=#{tid} \u003c/select\u003e \u003c--属性中的引用对象单独处理，对象：association，集合：collection--\u003e ","date":"2021-08-19","objectID":"/first_post/:14:0","tags":null,"title":"mybatis笔记","uri":"/first_post/"},{"categories":null,"content":"按照结果嵌套处理 \u003cselect id=\"getStudentList\" resultMap=\"StudentsTeacher2\"\u003e select s.id as sid,s.name as sname,s.tid as tid, t.name as tname from mybatis.student s join mybatis.teacher t on s.tid = t.id; \u003c/select\u003e \u003cresultMap id=\"StudentsTeacher2\" type=\"student\"\u003e \u003cresult property=\"id\" column=\"sid\"/\u003e \u003cresult property=\"name\" column=\"sname\"/\u003e \u003cassociation property=\"teacher\" javaType=\"teacher\"\u003e \u003cresult property=\"id\" column=\"tid\"/\u003e \u003cresult property=\"name\" column=\"tname\"/\u003e \u003c/association\u003e \u003c/resultMap\u003e 多对一查询方式： 子查询 联表查询 一对多处理 创建javaBean public class Student { private int id; private String name; private int tid; } public class Teacher { private int id; private String name; private List\u003cStudent\u003e students; } ","date":"2021-08-19","objectID":"/first_post/:15:0","tags":null,"title":"mybatis笔记","uri":"/first_post/"},{"categories":null,"content":"按照查询嵌套处理(子查询) \u003cselect id=\"getTeacher2\" resultMap=\"TeacherStudent2\"\u003e select * from teacher where id=#{tid} \u003c/select\u003e \u003cresultMap id=\"TeacherStudent2\" type=\"Teacher\"\u003e \u003c!--一样的省略--\u003e \u003ccollection property=\"students\" javaType=\"ArrayList\" ofType=\"Student\" column=\"id\" select=\"getStudentByTeacherId\"/\u003e \u003c/resultMap\u003e \u003cselect id=\"getStudentByTeacherId\" resultType=\"Student\"\u003e \u003c!--这里#{里面的可以随便写，第一个SQL的不行}--\u003e select * from student where tid=#{kkkk} \u003c/select\u003e 关联（对象）：association 【多对一】 集合：collection 【一对多】 javaType 用来指定实体类中的属性类型 ofType 用来指定映射到List或集合中的pojo类型，泛型中约束的类型 注意点： 保证SQL可读性，尽量保证通俗易懂 注意一对多和多对一中属性名和字段的问题 若错误不好排查，可以使用日志，建议使用Log4j 面试高频： MySQL引擎 innoDB底层原理 索引 索引优化 动态SQL 动态SQL是根据不同条件来生成不同的SQL语句 ","date":"2021-08-19","objectID":"/first_post/:16:0","tags":null,"title":"mybatis笔记","uri":"/first_post/"},{"categories":null,"content":"编写SQL，创建数据库表 CREATETABLE`blog`(`id`VARCHAR(50)NOTNULLCOMMENT'博客id',`title`VARCHAR(100)NOTNULLCOMMENT'博客标题',`author`VARCHAR(30)NOTNULLCOMMENT'博客作者',`create_time`DATETIMENOTNULLCOMMENT'创建时间',`views`INT(30)NOTNULLCOMMENT'浏览量')ENGINE=INNODBDEFAULTCHARSET=utf8; ","date":"2021-08-19","objectID":"/first_post/:17:0","tags":null,"title":"mybatis笔记","uri":"/first_post/"},{"categories":null,"content":"测试环境搭建 导包 创建javaBean @Data @AllArgsConstructor @NoArgsConstructor public class Blog { private String id; private String title; private String author; private Date createTime; private int views; } 建立Mapper接口 public interface BlogMapper { //插入数据 int addBook(Blog blog); //查询博客 List\u003cBlog\u003e queryBlogIF(Map map); // List\u003cBlog\u003e queryBlogChoose(Map map); int updateBlog(Map map); //查询第1-2-3号记录的博客 List\u003cBlog\u003e queryBlogForeach(Map map); } 建立Mapper.xml文件夹 在mybatis-config文件中绑定mapper接口或配置文件 测试查询 ","date":"2021-08-19","objectID":"/first_post/:18:0","tags":null,"title":"mybatis笔记","uri":"/first_post/"},{"categories":null,"content":"IF \u003cselect id=\"queryBlogIF\" parameterType=\"map\" resultType=\"blog\"\u003e select * from mybatis.blog \u003cwhere\u003e \u003cif test=\"title != null\"\u003e title = #{title} \u003c/if\u003e \u003cif test=\"author != null\"\u003e and author = #{author} \u003c/if\u003e \u003c/where\u003e \u003c/select\u003e 常用的部分可以作为SQL片段 在需要使用的地方使用include标签引用 \u003csql id=\"if-title-author\"\u003e \u003cif test=\"title != null\"\u003e title = #{title} \u003c/if\u003e \u003cif test=\"author != null\"\u003e and author = #{author} \u003c/if\u003e \u003c/sql\u003e \u003cselect id=\"queryBlogIF\" parameterType=\"map\" resultType=\"blog\"\u003e \u003c!-- select * from blog--\u003e \u003c!-- \u003cwhere\u003e--\u003e \u003c!-- \u003cif test=\"title != null\"\u003e--\u003e \u003c!-- title = #{title}--\u003e \u003c!-- \u003c/if\u003e--\u003e \u003c!-- \u003cif test=\"author != null\"\u003e--\u003e \u003c!-- and author = #{author}--\u003e \u003c!-- \u003c/if\u003e--\u003e \u003c!-- \u003c/where\u003e--\u003e select * from blog \u003cwhere\u003e \u003cinclude refid=\"if-title-author\"\u003e\u003c/include\u003e \u003c/where\u003e \u003c/select\u003e ","date":"2021-08-19","objectID":"/first_post/:19:0","tags":null,"title":"mybatis笔记","uri":"/first_post/"},{"categories":null,"content":"choose \u003cselect id=\"queryBlogChoose\" parameterType=\"map\" resultType=\"blog\"\u003e select * from blog \u003cwhere\u003e \u003cchoose\u003e \u003cwhen test=\"title != null\"\u003e title = #{title} \u003c/when\u003e \u003cwhen test=\"author != null\"\u003e and author = #{author} \u003c/when\u003e \u003cotherwise\u003e and views = #{views} \u003c/otherwise\u003e \u003c/choose\u003e \u003c/where\u003e \u003c/select\u003e ","date":"2021-08-19","objectID":"/first_post/:20:0","tags":null,"title":"mybatis笔记","uri":"/first_post/"},{"categories":null,"content":"set \u003cupdate id=\"updateBlog\" parameterType=\"map\"\u003e update blog \u003cset\u003e \u003cif test=\"title != null\"\u003e title = #{title}, \u003c/if\u003e \u003cif test=\"author != null\"\u003e author = #{author} \u003c/if\u003e \u003c/set\u003e where id = #{id} \u003c/update\u003e \u003c!--我们现在传递一个万能的map，map里面放一个集合 select * from blog where 1=1 and (id=1 or id=2 or id=3) --\u003e ","date":"2021-08-19","objectID":"/first_post/:21:0","tags":null,"title":"mybatis笔记","uri":"/first_post/"},{"categories":null,"content":"Foreach \u003cselect id=\"queryBlogForeach\" parameterType=\"map\" resultType=\"blog\"\u003e select * from mybatis.blog \u003cwhere\u003e \u003c!-- id in \u003cforeach collection=\"ids\" item=\"id\" open=\"(\" separator=\",\" close=\")\"\u003e #{id} \u003c/foreach\u003e --\u003e \u003cforeach collection=\"ids\" item=\"id\" separator=\"or\"\u003e id = #{id} \u003c/foreach\u003e \u003c/where\u003e \u003c/select\u003e 两种foreach SQL语句的区别 select * from mybatis.blog WHERE id in ( ? , ? , ? ) select * from mybatis.blog WHERE id = ? or id = ? or id = ? ","date":"2021-08-19","objectID":"/first_post/:22:0","tags":null,"title":"mybatis笔记","uri":"/first_post/"},{"categories":null,"content":"trim \u003cupdate id=\"updateBlogTrim\" parameterType=\"map\"\u003e update mybatis.blog \u003ctrim prefix=\"set\" suffixOverrides=\",\"\u003e \u003cif test=\"title != null\"\u003e title = #{title}, \u003c/if\u003e \u003cif test=\"author != null\"\u003e author = #{author}, \u003c/if\u003e \u003cif test=\"views != null\"\u003e views = #{views} \u003c/if\u003e \u003c/trim\u003e where id = #{id}; \u003c/update\u003e \u003cselect id=\"queryBlogTrim\" parameterType=\"map\" resultType=\"blog\"\u003e select * from mybatis.blog \u003ctrim prefix=\"WHERE\" prefixOverrides=\"AND |OR \"\u003e \u003cif test=\"title != null\"\u003e title = #{title} \u003c/if\u003e \u003cif test=\"author != null\"\u003e and author = #{author} \u003c/if\u003e \u003c/trim\u003e \u003c/select\u003e 总结： where元素在子元素存在（有值）的情况下才插入 “WHERE” 子句。而且，若子句的开头为 “AND” 或 “OR”，where 元素也会将它们去除。 注意事项： 最好基于单表来定义sql片段 不要存在where标签 缓存 **查询：**连接数据库，耗资源！一次查询的结果，给他暂存在一个可以直接取到的地方！—\u003e内存：缓存我们再次查询相同数据的时候，直接走缓存，就不用走数据库了 什么是缓存 [ Cache ]？ 存在内存中的临时数据。 将用户经常查询的数据放在缓存（内存）中，用户去查询数据就不用从磁盘上(关系型数据库数据文件)查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题。 为什么使用缓存？ 减少和数据库的交互次数，减少系统开销，提高系统效率。 什么样的数据能使用缓存？ 经常查询并且不经常改变的数据。【可以使用缓存】 ","date":"2021-08-19","objectID":"/first_post/:23:0","tags":null,"title":"mybatis笔记","uri":"/first_post/"},{"categories":null,"content":"mybatis缓存 MyBatis包含一个非常强大的查询缓存特性，它可以非常方便地定制和配置缓存。缓存可以极大的提升查询效率。 MyBatis系统中默认定义了两级缓存： 一级缓存和二级缓存 默认情况下，只有一级缓存开启。（SqlSession级别的缓存，也称为本地缓存） 二级缓存需要手动开启和配置，他是基于namespace级别的缓存。 为了提高扩展性，MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来自定义二级缓存 ","date":"2021-08-19","objectID":"/first_post/:24:0","tags":null,"title":"mybatis笔记","uri":"/first_post/"},{"categories":null,"content":"一级缓存 一级缓存也叫本地缓存： SqlSession 与数据库同一次会话期间查询到的数据会放在本地缓存中。 以后如果需要获取相同的数据，直接从缓存中拿，没必须再去查询数据库； 测试步骤： 开启日志！ 测试在一个Sesion中查询两次相同记录 查看日志输出 缓存失效的情况： 查询不同的东西 @Test public void queryUserById(){ SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); User user = mapper.queryUserById(1); logger.info(\"一级缓存：\" + user); User user1 = mapper.queryUserById(2); logger.info(\"一级缓存：\" + user1); logger.info(\"一级缓存：\" + (user == user1)); sqlSession.close(); } 增删改操作，可能会改变原来的数据，所以必定会刷新缓存！ @Test public void queryUserById(){ SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); User user = mapper.queryUserById(1); logger.info(\"一级缓存：\" + user); mapper.updateUser(new User(2,\"张三\",\"123456\")); User user1 = mapper.queryUserById(1); logger.info(\"一级缓存：\" + user1); logger.info(\"一级缓存：\" + (user == user1)); sqlSession.close(); } 查询不同的Mapper.xml 手动清理缓存！ @Test public void queryUserById(){ SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); User user = mapper.queryUserById(1); logger.info(\"一级缓存：\" + user); // 清除缓存 sqlSession.clearCache(); User user1 = mapper.queryUserById(1); logger.info(\"一级缓存：\" + user1); logger.info(\"一级缓存：\" + (user == user1)); sqlSession.close(); } ","date":"2021-08-19","objectID":"/first_post/:25:0","tags":null,"title":"mybatis笔记","uri":"/first_post/"},{"categories":null,"content":"二级缓存 二级缓存也叫全局缓存，一级缓存作用域太低了，所以诞生了二级缓存 基于namespace级别的缓存，一个名称空间，对应一个二级缓存； 工作机制 一个会话查询一条数据，这个数据就会被放在当前会话的一级缓存中； 如果当前会话关闭了，这个会话对应的一级缓存就没了；但是我们想要的是，会话关闭了，一级缓存中的数据被保存到二级缓存中； 新的会话查询信息，就可以从二级缓存中获取内容； 不同的mapper查出的数据会放在自己对应的缓存（map）中； 步骤： 开启全局缓存 \u003c!--显示的开启全局缓存--\u003e \u003csetting name=\"cacheEnabled\" value=\"true\"/\u003e 在要使用二级缓存的Mapper中开启 \u003c!--在当前mapper.xml中使用二级缓存--\u003e \u003ccache/\u003e 自定义参数 \u003c!--在当前Mapper.xml中使用二级缓存--\u003e \u003ccache eviction=\"FIFO\" flushInterval=\"60000\" size=\"512\" readOnly=\"true\"/\u003e 测试 @Test public void queryUserById(){ SqlSession sqlSession1 = MybatisUtils.getSqlSession(); SqlSession sqlSession2 = MybatisUtils.getSqlSession(); UserMapper mapper1 = sqlSession1.getMapper(UserMapper.class); UserMapper mapper2 = sqlSession2.getMapper(UserMapper.class); User user1 = mapper1.queryUserById(1); logger.info(\"一级缓存：\" + user1); sqlSession1.close(); User user2 = mapper2.queryUserById(1); logger.info(\"一级缓存：\" + user1); logger.info(\"一级缓存：\" + (user1 == user2)); sqlSession2.close(); } **问题：**我们需要将实体类序列化！否则就会报错！ Caused by: java.io.NotSerializableException: com.bin.pojo.User 小结： 只要开启了二级缓存，在同一个Mapper下就有效 所有的数据都会先放在一级缓存中； 只有当会话提交，或者关闭的时候，才会提交到二级缓冲中！ ","date":"2021-08-19","objectID":"/first_post/:26:0","tags":null,"title":"mybatis笔记","uri":"/first_post/"},{"categories":null,"content":"缓存原理 ","date":"2021-08-19","objectID":"/first_post/:27:0","tags":null,"title":"mybatis笔记","uri":"/first_post/"},{"categories":null,"content":"自定义缓存-ehcache Ehcache是一种广泛使用的开源Java分布式缓存。主要面向通用缓存` 先要导包！ \u003c!-- https://mvnrepository.com/artifact/org.mybatis.caches/mybatis-ehcache --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis.caches\u003c/groupId\u003e \u003cartifactId\u003emybatis-ehcache\u003c/artifactId\u003e \u003cversion\u003e1.1.0\u003c/version\u003e \u003c/dependency\u003e 在mapper中指定使用我们的ehcache缓存实现！ \u003c!--在当前Mapper.xml中使用二级缓存--\u003e \u003ccache type=\"org.mybatis.caches.ehcache.EhcacheCache\"/\u003e **Mybatis详细的执行流程！**⭐ ","date":"2021-08-19","objectID":"/first_post/:28:0","tags":null,"title":"mybatis笔记","uri":"/first_post/"}]